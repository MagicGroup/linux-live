#!/bin/bash 
# Linux Live Kit version 7
# 构建用脚本

# 添加执行文件的路径
export PATH=.:./tools:../tools:/usr/sbin:/usr/bin:/sbin:/bin:/

# 进入制作脚本的实际路径
CHANGEDIR=$(dirname $(readlink -f $0))
echo "Changing current directory to $CHANGEDIR"
CWD="$(pwd)"
cd $CHANGEDIR

# 引入 .config 和 livekitlib
. ./config || exit 1
. ./livekitlib || exit 1

# 只允许 root 运行脚本，函数都定义在 livekitlib 中。
# only root can continue, because only root can read all files from your system
allow_only_root

# check for xz
if [ "$(xz --help 2>&1 | grep -i "Compress")" = "" ]; then
   echo "xz not found or cannot compress"
   echo "没找到 xz 或 xz 不能压缩"
   echo "you may consider installing xz-tools package"
   echo "你需要安装 xz 工具包"
   exit 1
fi

# 检查 mksquashfs 是否支持 xz 压缩
# check for mksquashfs with xz compression
if [ "$(mksquashfs 2>&1 | grep "Xdict-size")" = "" ]; then
   echo "mksquashfs not found or doesn't support -comp xz, aborting, no changes made"
　 echo "mksquashfs 不支持 -comp xz 参数，退出，没有任何更改"
   exit 1
fi


MKISOFS=$(which mkisofs)
if [ "$MKISOFS" = "" ]; then
   MKISOFS=$(which genisoimage)
fi
if [ "$MKISOFS" = "" ]; then
   echo "Cannot find mkisofs or genisoimage, stop"
   echo "找不到 mkisofs 或 genisoimage，停止"
   exit 3
fi

# 构建 initramfs 镜像
# build initramfs image
if [ "$SKIPINITRFS" = "" ]; then
  echo "Building intramfs image..."
  echo "创建 initramfs 镜像..."
  # 进入 initramfs 目录
  cd initramfs
  # 使用 initramfs_create 脚本
  INITRAMFS=$(./initramfs_create)
  cd ..
fi

# 创建 live 的文件系统
# create live kit filesystem (cpio archive)
# 删除临时目录
rm -Rf "$LIVEKITDATA"
if [ $USEKITNAME = "1" ] ; then
	BOOT="$LIVEKITDATA"/"$LIVEKITNAME"/BOOT
else
	BOOT="$LIVEKITDATA"/BOOT
fi
echo $BOOT
mkdir -p "$BOOT"
mkdir -p "$LIVEKITDATA"/"$LIVEKITNAME"
if [ $USEKITNAME = "0" ] ; then
	mkdir -p "$BOOT"/../changes
	mkdir -p "$BOOT"/../modules
else
        mkdir -p "LIVEKITDATA"/"$LIVEKITNAME"/changes
        mkdir -p "LIVEKITDATA"/"$LIVEKITNAME"/modules
fi
if [ "$INITRAMFS" != "" ]; then
   mv -v "$INITRAMFS" $BOOT/initrfs.img
fi
if [ $USEGRUB = "1" ]; then
	cp -r bootfiles/* $BOOT
else
	cp bootfiles/* $BOOT
fi
if [ $USEKITNAME = "1" ] ;then
	cat bootfiles/syslinux.cfg | sed -r "s:/boot/:/$LIVEKITNAME/boot/:" > $BOOT/syslinux.cfg
	cat bootfiles/bootinst.bat | sed -r "s:/boot/:/$LIVEKITNAME/boot/:" | sed -r "s:\\\\boot\\\\:\\\\$LIVEKITNAME\\\\boot\\\\:" > $BOOT/bootinst.bat
else
echo "USEKITNAME=0"
fi
cp $VMLINUZ $BOOT/vmlinuz || exit

#UEFI 启动
# UEFI booting
ARCH=$(uname -m)
mkdir -p $BOOT/EFI/Boot
cp bootfiles/EFI/Boot/syslinux.efi $BOOT/EFI/Boot/bootx64.efi
cp bootfiles/EFI/Boot/{ldlinux.e64,menu.c32,libutil.c32,vesamenu.c32,libcom32.c32} $BOOT/EFI/Boot
cat $BOOT/syslinux.cfg | sed -r "s:/$LIVEKITNAME/boot/vesamenu:vesamenu:" > $BOOT/EFI/Boot/syslinux.cfg

# create compressed 01-core.sb
# 参考 linux-live ，只用一个文件，为后续安装做好准备
COREFS=""
for i in $MKMOD; do
   if [ -d /$i ]; then
      COREFS="$COREFS /$i"
   fi
done
mkdir -p $LIVEKITDATA/$LIVEKITNAME/modules/
case "$ARCH" in
    x86_64|i386|i686)
        BCJ_OPT="-Xbcj x86"
        ;;
    aarch64|armv7l|armv8l)
        BCJ_OPT="-Xbcj arm"
        # 若需针对ARM Thumb指令集优化，可进一步检测：
        # if grep -q "Thumb" /proc/cpuinfo; then
        #     BCJ_OPT="armthumb"
        # fi
        ;;
    powerpc|ppc64le)
        BCJ_OPT="-Xbcj powerpc"
        ;;
    sparc*)
        BCJ_OPT="-Xbcj sparc"
        ;;
    *)
        # 未知架构或不支持时，跳过优化或使用默认值
        BCJ_OPT=""
        ;;
    esac
if [ "$SKIPCOREMOD" = "" ]; then
   mksquashfs $COREFS $LIVEKITDATA/$LIVEKITNAME/modules/01-core.$BEXT -comp xz -b 1024K $BCJ_OPT -always-use-fragments -keep-as-directory -ef $EXCLUDELIST || exit
fi

# 复制 rootcopy 文件夹
# copy rootcopy folder
if [ -d rootcopy ]; then
   cp -a rootcopy $LIVEKITDATA/$LIVEKITNAME/
fi

# 创建光盘镜像
# create ISO for CD image
echo "Creating ISO file for CD boot..."
echo "创建可启动的光盘 ISO 镜像..."
cd "$LIVEKITDATA"
# 默认目标路径，需要按情况修改
TARGET=/mnt/z
if [ ! -d $TARGET ]; then
# 不改的话，默认是 /tmp 目录，请注意 /tmp 的大小
   TARGET=/tmp
fi

# 制作 iso，支持 grub4dos 和 syslinux
if [ $USEGRUB = "1" ];then
	MKISOFSB="-b BOOT/GRUB/grldr"
	MKISOFSC="-c BOOT/boot.catalog"
else
	MKISOFSB="-b BOOT/isolinux.bin"
	MKISOFSC="-c BOOT/isolinux.boot"
fi
if [ $USEKITNAME = "1" ]; then
	cd $LIVEKITDATA '&&' $MKISOFS -o "$TARGET/$LIVEKITNAME-$ARCH.iso" -v -J -R -D -A "$LIVEKITNAME" -V "$LIVEKITNAME" \
	-no-emul-boot -boot-info-table -boot-load-size 4 \
	-b "$LIVEKITNAME"/boot/isolinux.bin -c "$LIVEKITNAME"/boot/isolinux.boot . \
	> $TARGET/gen_"$LIVEKITNAME"_iso.sh
else
        cd $LIVEKITDATA '&&' $MKISOFS -o "$TARGET/$LIVEKITNAME-$ARCH.iso" -v -J -R -D -A "$LIVEKITNAME" -V "$LIVEKITNAME" \
       	-no-emul-boot -boot-info-table -boot-load-size 4 \
 	$MKISOFSB $MKISOFSC . \
	> $TARGET/gen_"$LIVEKITNAME"_iso.sh
fi
chmod o+x $TARGET/gen_"$LIVEKITNAME"_iso.sh

# 生成 readme.txt 文件
cat "$CWD/bootinfo.txt" | fgrep -v "#" | sed -r "s/mylinux/$LIVEKITNAME/" | sed -r "s/\$//" > readme.txt
# 生成U盘和硬盘启动的压缩包
echo "Creating ZIP for USB boot..."
echo "创建 USB 启动用的压缩包..."
rm -f "$TARGET/$LIVEKITNAME-$ARCH.zip"
zip -0 -r "$TARGET/$LIVEKITNAME-$ARCH.zip" *

cd ..
rm -Rf "$LIVEKITDATA"
echo "finished. Find your result in $TARGET"
echo "制作完成，可以在 $TARGET 中找到制作成果"
